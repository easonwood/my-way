[https://github.com/easonwood/my-way/blob/master/1%20JDK/1.png]
[https://github.com/easonwood/my-way/blob/master/1%20JDK/2.png]


jvm工作三大重要组成部分架构图，
它包含了类加载子系统、运行时数据区域、执行引擎。
一提及到jvm执行原理我们应该脑海中应该是这样的一张架构图，
我们写的java文件首先通过javac编译成class文件，类加载子系统把class文件加载到内存中，并且存放到相应划分的区域，然后再由jvm执行引擎执行。

步骤：
(1) 根据系统环境变量，创建装载JVM的环境与配置；
(2) 寻找JRE目录，寻找jvm.dll，并装载jvm.dll；
(3) 根据JVM的参数配置，如：内存参数，初始化jvm实例；
(4) JVM实例产生一个引导类加载器实例（Bootstrap Loader），加载Java核心库，然后引导类加载器自动加载扩展类加载器（Extended Loader）,加载Java扩展库，最后扩展类加载器自动加载系统类加载器（AppClass Loader），加载当前的Java类；
(5) 当前Java类加载至内存后，会经过验证、准备、解析三步，将Java类中的类型信息、属性信息、常量池存放在方法区内存中，方法指令直接保存到栈内存中，如：main函数；
(6) 执行引擎开始执行栈内存中指令，由于main函数是静态方法，所以不需要传入实例，在类加载完毕之后，直接执行main方法指令；
(7) main函数执行主线程结束，在所有非守护线程结束后，随之守护线程销毁，最后JVM实例被销毁；


Java线程之间的通信由Java内存模型（本文简称为JMM）控制，
JMM决定一个线程对共享变量的写入何时对另一个线程可见。
从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：
线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。
本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。
Java内存模型的抽象示意图如下：
[https://github.com/easonwood/my-way/blob/master/1%20JDK/3.png]

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：
	1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
	2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 下面通过示意图来说明这两个步骤：

[https://github.com/easonwood/my-way/blob/master/1%20JDK/4.png]

进程：系统进行资源分配和调度的一个独立单位，有独立的地址空间。切换耗费资源大线程：进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。自己只拥有程序计数器、寄存器和栈，共享进程的堆。一个线程死掉就导致进程死掉

并行：同一时间点同时执行。进程间独立，多cpu多进程可实现并行

并发：同一时间片段同时执行。共享一个cpu的多线程只能并发，实际将cpu时间切片，一个片段只能有一个线程执行
cpu繁忙时，操作系统只为一个含有多线程的进程分配一个cpu，这些线程就排队申请调用cpu，就是多线程并发
cpu充足时，一个进程的多线程，可能被分配到多个cpu，多线程可能会并行
主内存 → 线程工作内存：多对一关系，工作内存以缓存行cache line形式，大小单位为64B
伪共享：同一个cache line中的变量，一个的值变了，其他的也会被invalid而需要重新加载主内存
缓存行填充：
用无关变量（7个long型）填满一个cache line
double、long（8B）
int、float（4B）
short、char（2B）
boolean、byte（1B）
reference（4B+、8B的整数倍）引用对象都有4B（32位JVM）的对象头，存入地址都是8B的整数倍
此方法适用JDK6，JDK7会优化无用字段需要继承类无用字段，JDK8添加@Contended注解自动填充， -XX:-RestrictContended